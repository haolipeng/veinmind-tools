# Veinmind 漏洞扫描类插件技术分析

本文档涵盖 3 个漏洞扫描类插件的深度技术分析。

---

## 1. veinmind-vuln - 综合漏洞扫描

**功能概述**: 基于 Trivy 和 OSV API 进行软件成分分析和漏洞检测。

### 1.1 Trivy 引擎集成

```go
// plugins/go/veinmind-vuln/analyzer/analyzer.go:55-96
func ScanAsset(fileSystem api.FileSystem, parallel int64) *analyzer.AnalysisResult {
    ctx := context.Background()
    limit := semaphore.NewWeighted(parallel)  // 信号量并发控制
    res := analyzer.NewAnalysisResult()

    ag := analyzer.NewAnalyzerGroup(artifactOpt.AnalyzerGroup, artifactOpt.DisabledAnalyzers)

    fileSystem.Walk("/", func(path string, info fs.FileInfo, err error) error {
        open := func() (dio.ReadSeekCloserAt, error) {
            return fileSystem.Open(path)
        }

        // Trivy 分析器处理每个文件
        ag.AnalyzeFile(ctx, &wg, limit, res, "", path, info, open, nil, opts)
        return nil
    })

    wg.Wait()
    res.Sort()
    return res
}
```

### 1.2 OSV API 批量查询

```go
// plugins/go/veinmind-vuln/analyzer/osv.go:24-91
func ScanOSV(res *model.ScanResult, verbose bool) {
    bqs := transferQuery(res)

    for _, bq := range bqs {
        resp, _ := osv.MakeRequest(bq)

        // 填充漏洞信息
        for hi, hr := range resp.Results {
            for _, v := range hr.Vulns {
                req := bq.Queries[hi]
                res.Applications[ai].Libraries[req.Package.Index].Vulnerabilities =
                    append(..., v)
            }
        }
    }
}

func transferQuery(res *model.ScanResult) []osv.BatchedQuery {
    bq := &osv.BatchedQuery{Queries: make([]*osv.Query, 0)}

    for _, pkgs := range res.PackageInfos {
        for _, pkg := range pkgs.Packages {
            // 每 1000 个查询分批
            if len(bq.Queries) > 1000 {
                bquerys = append(bquerys, *bq)
                bq = &osv.BatchedQuery{Queries: make([]*osv.Query, 0)}
            }

            bq.Queries = append(bq.Queries, &osv.Query{
                Version: pkg.Version,
                Package: osv.Package{
                    Name:      pkg.Name,
                    Ecosystem: "Debian",
                },
            })
        }
    }
    return bquerys
}
```

### 1.3 OSV API 请求实现

```go
// plugins/go/veinmind-vuln/sdk/osv/osv.go:62-95
const (
    QueryEndpoint        = "https://api.osv.dev/v1/querybatch"
    MaxQueriesPerRequest = 1000
)

func MakeRequest(request BatchedQuery) (*BatchedResponse, error) {
    // API 限制每次 1000 个查询
    queryChunks := chunkBy(request.Queries, MaxQueriesPerRequest)
    var totalOsvResp BatchedResponse

    for _, queries := range queryChunks {
        requestBytes, _ := json.Marshal(BatchedQuery{Queries: queries})
        requestBuf := bytes.NewBuffer(requestBytes)

        resp, _ := http.Post(QueryEndpoint, "application/json", requestBuf)

        var osvResp BatchedResponse
        decoder := json.NewDecoder(resp.Body)
        decoder.Decode(&osvResp)

        totalOsvResp.Results = append(totalOsvResp.Results, osvResp.Results...)
    }

    return &totalOsvResp, nil
}
```

### 1.4 多包管理器支持

```go
// plugins/go/veinmind-vuln/analyzer/osv.go:9-22
var AppMap = map[string]string{
    "gobinary":        "Go",
    "gomod":           "Go",
    "python-pkg":      "PyPI",
    "pip":             "PyPI",
    "pipenv":          "PyPI",
    "jar":             "Maven",
    "pom":             "Maven",
    "gradle-lockfile": "Maven",
    "npm":             "npm",
    "node-pkg":        "npm",
    "yarn":            "npm",
    "pnpm":            "npm",
}
```

**支持的生态系统**:
- Go (gobinary, gomod)
- Python (pip, pipenv, python-pkg)
- Java (jar, pom, gradle)
- Node.js (npm, yarn, pnpm)

---

## 2. veinmind-log4j2 - Log4j2 漏洞检测

**功能概述**: 检测 Log4j2 远程代码执行漏洞 (CVE-2021-44228)。

### 2.1 嵌套 JAR 递归扫描

```go
// plugins/go/veinmind-log4j2/pkg/scanner/scanner.go:74-179
func ScanFile(file api.File, path string, depth int) (*Result, error) {
    // 深度控制，防止无限递归
    if depth >= JarDetectDepth {
        return nil, errors.New("exceed jar detect depth")
    }

    f, _ := zip.NewReader(file, stat.Size())

    hasLookUp := false
    fixed := false

    for _, ff := range f.File {
        fname := strings.ToLower(ff.Name)
        ext := filepath.Ext(fname)

        // 检测漏洞类文件
        if strings.HasSuffix(fname, "log4j/core/lookup/jndilookup.class") {
            hasLookUp = true
        } else if strings.HasSuffix(fname, "log4j/core/net/jndimanager.class") {
            // 检查是否已修复
            buf := make([]byte, 1024000)
            io.ReadFull(reader, buf)
            if bytes.Contains(buf, []byte("Invalid JNDI URI")) {
                fixed = true
            }
        } else if strings.HasSuffix(fname, "log4j/core/lookup/interpolator.class") {
            // 检查 JNDI 引用
            if bytes.Contains(buf, []byte("log4j.core.lookup.JndiLookup")) {
                refs = append(refs, ff.Name)
            }
        } else if ext == ".jar" {
            // 递归扫描嵌套 JAR
            result, _ := ScanFile(tmpFile, ff.Name, depth+1)
            if result.Code == Vulnerable {
                result.DisplayPath = fmt.Sprintf("%s -> %s", path, ff.Name)
                return result, nil
            }
        }
    }

    // 判断漏洞状态
    if len(refs) > 0 {
        if fixed || !hasLookUp {
            return &Result{Code: FixedVersion}, nil
        }
        return &Result{Code: Vulnerable}, nil
    }
    return &Result{Code: NotDetected}, nil
}
```

### 2.2 漏洞检测逻辑

**检测步骤**:
1. 查找 `JndiLookup.class` - JNDI 查找功能入口
2. 检查 `JndiManager.class` 中是否包含修复标记 (`Invalid JNDI URI`)
3. 检查 `Interpolator.class` 中的 JNDI 引用
4. 递归处理嵌套 JAR 文件

**结果状态**:
```go
const (
    NotDetected = iota  // 未检测到 Log4j2
    Vulnerable          // 存在漏洞
    FixedVersion        // 已修复版本
)
```

### 2.3 文件扫描入口

```go
// plugins/go/veinmind-log4j2/pkg/scanner/scanner.go:50-72
func Scan(path string, id string, res *[]*Result, openFile func(path string) (api.File, error)) error {
    ext := strings.ToLower(filepath.Ext(path))

    // 只扫描 JAR/WAR 文件
    if ext == ".jar" || ext == ".war" {
        file, _ := openFile(path)
        result, _ := ScanFile(file, path, 0)

        if result.Code == Vulnerable {
            *res = append(*res, result)
            log.Warnf("[Vulnerable] image: %s, file: %s", id, result.DisplayPath)
        }
    }
    return nil
}
```

---

## 3. veinmind-minio - MinIO CVE 检测

**功能概述**: 检测 MinIO 信息泄露漏洞 (CVE-2023-28432)。

### 3.1 二进制版本字符串提取

```go
// plugins/go/veinmind-minio/pkg/scanner/scanner.go:14-63
const REGEX = `RELEASE\.(\d{4}-\d{2}-\d{2})T(\d{2}-\d{2}-\d{2})Z`

var startVersion, _ = time.Parse("2006-01-02", "2019-12-17")
var endVersion, _ = time.Parse("2006-01-02", "2023-03-20")

func ScanImage(image api.Image) Result {
    image.Walk("/", func(path string, info fs.FileInfo, err error) error {
        if info.Name() == "minio" {
            r := regexp.MustCompile(REGEX)
            file, _ := image.Open(path)
            data, _ := io.ReadAll(file)

            // 从二进制中提取版本字符串
            matches := r.FindAllStringSubmatch(string(data), -1)
            if len(matches) > 0 {
                version := matches[len(matches)-1][1]
                v, _ := time.Parse("2006-01-02", version)

                // 日期范围判断
                if v.Equal(startVersion) ||
                   (v.Before(endVersion) && v.After(startVersion)) {
                    res.File = path
                    res.Version = matches[len(matches)-1][0]
                }
            }
        }
        return nil
    })
    return res
}
```

### 3.2 版本格式与范围

**版本格式**: `RELEASE.2023-03-20T20-16-18Z`

**漏洞影响范围**:
- 起始版本: `2019-12-17`
- 结束版本: `2023-03-20`

```go
// 版本范围判断
var startVersion, _ = time.Parse("2006-01-02", "2019-12-17")
var endVersion, _ = time.Parse("2006-01-02", "2023-03-20")

// 检查版本是否在漏洞范围内
if v.Equal(startVersion) || (v.Before(endVersion) && v.After(startVersion)) {
    // 存在漏洞
}
```

### 3.3 结果类型

```go
// plugins/go/veinmind-minio/pkg/scanner/types.go
type Result struct {
    File    string  // 二进制文件路径
    Version string  // 版本字符串
}
```

---

## 漏洞扫描类插件对比

| 特性 | veinmind-vuln | veinmind-log4j2 | veinmind-minio |
|------|--------------|-----------------|----------------|
| 检测范围 | 通用依赖漏洞 | Log4j2 特定漏洞 | MinIO 特定漏洞 |
| 检测引擎 | Trivy + OSV | 自研规则 | 自研规则 |
| 扫描对象 | 依赖清单文件 | JAR/WAR 文件 | 二进制文件 |
| 并发控制 | semaphore.Weighted | 无 | 无 |
| 缓存机制 | 无 | 无 | 无 |

---

*文档生成时间: 2026-01-20*
